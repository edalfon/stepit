{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"stepit","text":"<p>Yet another python decorator for persistent caching. <code>stepit</code> caches function results based on their source code and arguments, automatically invalidating the cache when either changes.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Smart Cache Invalidation: Cache is updated when function source code changes</li> <li>Recursive Awareness: Tracks changes in nested function calls</li> <li>Informative Logging: Color-coded progress and status messages</li> <li>Zero Configuration: Works out of the box with sensible defaults</li> <li>Customizable: Supports custom cache keys, directories, and serialization</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install stepit\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from stepit import stepit\n\n@stepit\ndef expensive_calculation(x):\n    # ... complex computation ...\n    return result\n\n# First call: computes and caches\nresult = expensive_calculation(42)\n# Second call: uses cache\nresult = expensive_calculation(42)\n</code></pre>"},{"location":"#advanced-usage","title":"Advanced Usage","text":""},{"location":"#recursive-functions-with-automatic-cache-invalidation","title":"Recursive Functions with Automatic Cache Invalidation","text":"<pre><code>@stepit\ndef fibonacci(n):\n    if n &lt;= 1: return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\n# First run: calculates and caches all intermediate results\nfibonacci(100)\n\n# Change the function\n@stepit\ndef fibonacci(n):  # Different implementation\n    if n &lt;= 0: return 0\n    if n == 1: return 1\n    return fibonacci(n-1) + fibonacci(n-2)\n\n# Cache is automatically invalidated due to source code change\nfibonacci(100)\n</code></pre>"},{"location":"#custom-cache-configuration","title":"Custom Cache Configuration","text":"<pre><code>@stepit(\n    key=\"my_special_function\",\n    cache_dir=\"custom_cache\"\n)\ndef process_data(x):\n    return x * 2\n</code></pre>"},{"location":"#informative-logging","title":"Informative Logging","text":"<pre><code>import logging\nlogging.getLogger(\"stepit\").setLevel(logging.DEBUG)\n\n@stepit\ndef add(a, b):\n    return a + b\n\nadd(1, 2)  # Outputs:\n# \u23e9 stepit 'add': Starting execution of `__main__.add()`\n# \u2705 stepit 'add': Successfully completed and cached [exec time 0 seconds, size 37 bytes]\n# \u267b\ufe0f  stepit 'add': is up-to-date. Using cached result\n</code></pre>"},{"location":"#use-cases","title":"Use Cases","text":"<ul> <li>Data processing pipelines</li> <li>Scientific computations</li> <li>Machine learning model training</li> <li>Any expensive computations that may be repeated</li> </ul>"},{"location":"#how-it-works","title":"How It Works","text":"<ol> <li>Creates a unique key based on:</li> <li>Function's source code</li> <li>Arguments</li> <li>Any nested <code>@stepit</code>-decorated function calls</li> <li>Checks if result exists in cache</li> <li>Executes function if:</li> <li>No cached result exists</li> <li>Source code has changed</li> <li>Arguments are different</li> <li>Stores result in cache for future use</li> </ol>"},{"location":"#license","title":"License","text":"<p>MIT License</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions welcome! Please check our GitHub repository for guidelines.</p>"},{"location":"api/","title":"stepit API","text":"<p>stepit package.</p> <p>project description</p>"},{"location":"api/#stepit.default_deserialize","title":"<code>default_deserialize(filename)</code>","text":"<p>Deserialize using pickle.</p> Source code in <code>src/stepit/stepit.py</code> <pre><code>def default_deserialize(filename):\n    \"\"\"Deserialize using pickle.\"\"\"\n    print(f\"Before reading: {os.listdir(os.path.dirname(filename))}\")\n    with open(filename, \"rb\") as f:\n        return pickle.load(f)\n</code></pre>"},{"location":"api/#stepit.default_serialize","title":"<code>default_serialize(result, filename)</code>","text":"<p>Serialize using pickle.</p> Source code in <code>src/stepit/stepit.py</code> <pre><code>def default_serialize(result, filename):\n    \"\"\"Serialize using pickle.\"\"\"\n    os.makedirs(os.path.dirname(filename), exist_ok=True)\n\n    print(f\"Before saving: {os.listdir(os.path.dirname(filename))}\")\n\n    with open(filename, \"wb\") as f:\n        pickle.dump(result, f)\n\n    print(f\"After saving: {os.listdir(os.path.dirname(filename))}\")\n</code></pre>"},{"location":"api/#stepit.stepit","title":"<code>stepit</code>","text":""},{"location":"api/#stepit.stepit._compute_recursive_hash","title":"<code>_compute_recursive_hash(func, seen=None)</code>","text":"<p>Computes a hash of the function's source code and, recursively, all stepit-decorated functions it calls.</p> Source code in <code>src/stepit/stepit.py</code> <pre><code>def _compute_recursive_hash(func, seen=None):\n    \"\"\"Computes a hash of the function's source code and, recursively,\n    all stepit-decorated functions it calls.\"\"\"\n\n    if seen is None:\n        seen = set()\n    if func in seen:\n        return \"\"\n\n    seen.add(func)\n\n    try:\n        logger.debug(f\"Computing hash for function {func.__qualname__}\")\n        source = inspect.getsource(func)\n        logger.debug(f\"Source code: {source}\")\n    except Exception:\n        logger.warning(f\"Couldn't get the source for: {func.__qualname__}\")\n        source = func.__qualname__  # fallback\n\n    try:\n        fnclvrs = inspect.getclosurevars(func)\n        logger.debug(f\"nonlocals: {fnclvrs.nonlocals}\")\n        logger.debug(f\"globals: {fnclvrs.globals}\")\n        logger.debug(f\"globals: {fnclvrs.builtins}\")\n        logger.debug(f\"globals: {fnclvrs.unbound}\")\n\n        for name, value in {**fnclvrs.nonlocals, **fnclvrs.globals}.items():\n            if callable(value) and hasattr(value, \"__stepit__\"):\n                source += _compute_recursive_hash(value, seen)\n\n    except Exception as e:\n        logger.warning(f\"Couldn't get closurevars: {func.__qualname__}, {e}\")\n\n    return hashlib.md5(source.encode(\"utf-8\")).hexdigest()\n</code></pre>"},{"location":"api/#stepit.stepit.create_symlink","title":"<code>create_symlink(symlink_path, target_file)</code>","text":"<p>Creates a symbolic link, handling cross-platform differences.</p> Source code in <code>src/stepit/stepit.py</code> <pre><code>def create_symlink(symlink_path, target_file):\n    \"\"\"Creates a symbolic link, handling cross-platform differences.\"\"\"\n    try:\n        if os.path.exists(symlink_path) or os.path.islink(symlink_path):\n            os.remove(symlink_path)  # Remove old symlink if it exists\n\n        os.symlink(target_file, symlink_path)  # Create new symlink\n\n    except OSError:\n        shutil.copy2(target_file, symlink_path)  # Fallback: Copy the file\n</code></pre>"},{"location":"api/#stepit.stepit.default_deserialize","title":"<code>default_deserialize(filename)</code>","text":"<p>Deserialize using pickle.</p> Source code in <code>src/stepit/stepit.py</code> <pre><code>def default_deserialize(filename):\n    \"\"\"Deserialize using pickle.\"\"\"\n    print(f\"Before reading: {os.listdir(os.path.dirname(filename))}\")\n    with open(filename, \"rb\") as f:\n        return pickle.load(f)\n</code></pre>"},{"location":"api/#stepit.stepit.default_serialize","title":"<code>default_serialize(result, filename)</code>","text":"<p>Serialize using pickle.</p> Source code in <code>src/stepit/stepit.py</code> <pre><code>def default_serialize(result, filename):\n    \"\"\"Serialize using pickle.\"\"\"\n    os.makedirs(os.path.dirname(filename), exist_ok=True)\n\n    print(f\"Before saving: {os.listdir(os.path.dirname(filename))}\")\n\n    with open(filename, \"wb\") as f:\n        pickle.dump(result, f)\n\n    print(f\"After saving: {os.listdir(os.path.dirname(filename))}\")\n</code></pre>"},{"location":"api/#stepit.stepit.format_size","title":"<code>format_size(size)</code>","text":"<p>Convert size to a human-readable format with appropriate units.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int or float</code> <p>The size in bytes.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>A string representing the size in a human-readable format (e.g., \"10 bytes\", \"2.5 KB\", \"1.8 MB\").</p> Source code in <code>src/stepit/stepit.py</code> <pre><code>def format_size(size):\n    \"\"\"\n    Convert size to a human-readable format with appropriate units.\n\n    Args:\n        size (int or float): The size in bytes.\n\n    Returns:\n        str: A string representing the size in a human-readable format (e.g., \"10 bytes\", \"2.5 KB\", \"1.8 MB\").\n    \"\"\"\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"]:\n        if size &lt; 1024.0:\n            return f\"{int(size)} {unit}\" if (size % 1) == 0 else f\"{size:.1f} {unit}\"\n        size /= 1024.0\n\n    unit = \"TB\"\n    return f\"{int(size)} {unit}\" if (size % 1) == 0 else f\"{size:.1f} {unit}\"\n</code></pre>"},{"location":"api/#stepit.stepit.format_time","title":"<code>format_time(seconds)</code>","text":"<p>Converts a given number of seconds into a human-readable time format.</p> <p>The function iteratively checks if the remaining time is less than 60, and if so, formats the time with the appropriate unit (seconds, minutes, hours, or days). If the time is less than 60 seconds, it returns the time as an integer number of seconds. Otherwise, it returns the time as a float with one decimal place, along with the unit.</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>float</code> <p>The number of seconds to convert.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>A string representing the formatted time.  Examples: \"5 seconds\", \"1.5 minutes\", \"2.3 hours\", \"1.1 days\"</p> Source code in <code>src/stepit/stepit.py</code> <pre><code>def format_time(seconds):\n    \"\"\"Converts a given number of seconds into a human-readable time format.\n\n    The function iteratively checks if the remaining time is less than 60, and if so,\n    formats the time with the appropriate unit (seconds, minutes, hours, or days).\n    If the time is less than 60 seconds, it returns the time as an integer number of seconds.\n    Otherwise, it returns the time as a float with one decimal place, along with the unit.\n\n    Args:\n        seconds (float): The number of seconds to convert.\n\n    Returns:\n        str: A string representing the formatted time.\n             Examples: \"5 seconds\", \"1.5 minutes\", \"2.3 hours\", \"1.1 days\"\n    \"\"\"\n    units = [(\"seconds\", 60), (\"minutes\", 60), (\"hours\", 24), (\"days\", None)]\n\n    seconds = float(seconds)  # Ensure float division\n    for unit, threshold in units:\n        if threshold is None or seconds &lt; threshold:\n            return (\n                f\"{int(seconds)} {unit}\"\n                if seconds.is_integer()\n                else f\"{seconds:.1f} {unit}\"\n            )\n        seconds /= threshold  # Convert to the next unit\n</code></pre>"},{"location":"api/#stepit.stepit.stepit","title":"<code>stepit(func=None, *, key=None, cache_dir='.stepit_cache', serialize=default_serialize, deserialize=default_deserialize)</code>","text":"<p>Decorator for persistent caching. Can be used with or without arguments:</p> <pre><code>@stepit\ndef my_func(x): ...\n\n@stepit(key=\"custom_key\", cache_dir=\"my_cache\")\ndef my_func(x): ...\n</code></pre> The cache key is based on <ul> <li>A custom prefix (if provided) or the function's fully qualified name by default.</li> <li>A recursive hash of its source (including decorated functions it calls).</li> <li>A hash of the call arguments.</li> </ul> Source code in <code>src/stepit/stepit.py</code> <pre><code>def stepit(\n    func=None,\n    *,\n    key=None,\n    cache_dir=\".stepit_cache\",\n    serialize=default_serialize,\n    deserialize=default_deserialize,\n):\n    \"\"\"\n    Decorator for persistent caching. Can be used with or without arguments:\n\n        @stepit\n        def my_func(x): ...\n\n        @stepit(key=\"custom_key\", cache_dir=\"my_cache\")\n        def my_func(x): ...\n\n    The cache key is based on:\n      - A custom prefix (if provided) or the function's fully qualified name by default.\n      - A recursive hash of its source (including decorated functions it calls).\n      - A hash of the call arguments.\n    \"\"\"\n    if callable(func):\n        return stepit()(func)\n\n    def decorator(func):\n        nonlocal key\n        if key is None:\n            # key = f\"{func.__module__}.{func.__qualname__}\"\n            key = f\"{func.__name__}\"\n            # let's use the simplest name (qual would need to be cleaned to be able\n            # to be used as a filename)\n\n        if not os.path.exists(cache_dir):\n            os.makedirs(cache_dir, exist_ok=True)\n\n        config = {\n            \"key\": key,\n            \"cache_dir\": cache_dir,\n            \"serialize\": serialize,\n            \"deserialize\": deserialize,\n        }\n\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            sorted_kwargs = tuple(sorted(kwargs.items()))\n            try:\n                pickled_args = pickle.dumps((args, sorted_kwargs))\n            except Exception:\n                pickled_args = func.__qualname__\n                logger.warning(f\"Cannot pickle args for {func.__qualname__}\")\n\n            args_hash = hashlib.md5(pickled_args).hexdigest()\n            source_hash = _compute_recursive_hash(func)\n            composite = f\"{source_hash}:{args_hash}\"\n            filename_hash = hashlib.md5(composite.encode(\"utf-8\")).hexdigest()\n\n            current = wrapper.__stepit_config__\n            cache_file = os.path.join(\n                current[\"cache_dir\"], f\"{current['key']}_{filename_hash}\"\n            )\n            key_file = os.path.join(current[\"cache_dir\"], f\"{current['key']}\")\n\n            if os.path.exists(cache_file):\n                try:\n                    logger.info(\n                        f\"\u267b\ufe0f  stepit '{config['key']}': is up-to-date. \"\n                        f\"Using cached result for \"\n                        f\"`{func.__module__}.{func.__qualname__}()`\"\n                    )\n                    create_symlink(key_file, cache_file)\n                    return current[\"deserialize\"](cache_file)\n                except Exception as e:\n                    logger.warning(\n                        f\"\u26a0\ufe0f stepit '{config['key']}': Could not load cache. \"\n                        f\"Need to execute again \"\n                        f\"`{func.__module__}.{func.__qualname__}()` \"\n                        f\"Underlying exception: {e}\"\n                    )\n\n            logger.info(\n                f\"\u23e9 stepit '{config['key']}': Starting execution of \"\n                f\"`{func.__module__}.{func.__qualname__}()`\"  # \u25b6\n            )\n            start_time = time.time()\n            result = func(*args, **kwargs)\n            exec_time = time.time() - start_time\n\n            try:\n                start_time = time.time()\n                current[\"serialize\"](result, cache_file)\n                create_symlink(key_file, cache_file)\n                persist_time = time.time() - start_time\n                file_size = os.path.getsize(cache_file)\n\n                formatted_size = format_size(file_size)\n                formatted_exec_time = format_time(exec_time)\n                formatted_persist_time = format_time(persist_time)\n\n                logger.info(\n                    f\"\u2705 stepit '{config['key']}': Successfully completed and cached \"\n                    f\"[exec time {formatted_exec_time}, \"\n                    f\"cache time {formatted_persist_time}, size {formatted_size}]\"\n                    f\" `{func.__module__}.{func.__qualname__}()`\"\n                )\n\n            except Exception as e:\n                logger.error(\n                    f\"\u274c  stepit '{config['key']}': Failed to save cache for \"\n                    f\"`{func.__module__}.{func.__qualname__}()` \"\n                    f\"Underlying exception: {e}\"\n                )\n\n            return result\n\n        wrapper.__stepit__ = True\n        wrapper.__stepit_config__ = config\n\n        def update(**kwargs):\n            wrapper.__stepit_config__.update(kwargs)\n            if \"cache_dir\" in kwargs and not os.path.exists(kwargs[\"cache_dir\"]):\n                os.makedirs(kwargs[\"cache_dir\"], exist_ok=True)\n            return wrapper\n\n        wrapper.update = update\n        return wrapper\n\n    return decorator\n</code></pre>"}]}